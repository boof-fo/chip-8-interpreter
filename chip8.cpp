#include <iostream>

#include "chip8.h"

//MEMORY
uint8_t memory[0x1000] = {0};
//interprete usa i primi 512 byte, quindi i programmi inziano dalla location 0x200 inclusa (alcuni da 0x600)
////gli ultimi 256 byte (0xF00-0xFFF) sono usati per il display
////i 96 byte prima del display (0xEA0-0xEFF) sono riservati per il call stack

//REGISTERS
uint8_t V[16], delay_timer, sound_timer, stack_pointer;
//V: vanno da V0 a VF; VF Ã¨ usato come flag per alcune istruzioni
uint16_t I, PC, stack[16];
//I: contiene indirizzi a memoria, quindi solo gli ultimi 12 bit sono usati

//DISPLAY
bool display[64][32];

uint8_t default_font[80] = {
	0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
	0x20, 0x60, 0x20, 0x20, 0x70, // 1
	0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
	0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
	0x90, 0x90, 0xF0, 0x10, 0x10, // 4
	0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
	0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
	0xF0, 0x10, 0x20, 0x40, 0x40, // 7
	0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
	0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
	0xF0, 0x90, 0xF0, 0x90, 0x90, // A
	0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
	0xF0, 0x80, 0x80, 0x80, 0xF0, // C
	0xE0, 0x90, 0x90, 0x90, 0xE0, // D
	0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
	0xF0, 0x80, 0xF0, 0x80, 0x80  // F
};
//da mettere in memoria da 050 a 09F


int cycle(){
	uint16_t opcode, instruction;
	//FETCH
	instruction = memory[PC] << 8 | memory[PC + 1];
	PC = PC +2;


	//DECODE
	uint16_t x, y, n, nnn, kk;
	opcode = instruction & 0xF000;

	x = (instruction >> 8) & 0x000F;//the lower 4 bits of the high byte of the instruction
	y = (instruction >> 4) & 0x000F;//the upper 4 bits of the low byte of the instruction
	n = instruction & 0x000F;//the lowest 4 bits of the instruction
	kk = instruction & 0x00FF;//the lowest 8 bits of the instruction
	nnn = instruction & 0x0FFF;//lowest 12 bits of the instruction


	//EXECUTE
	switch (opcode){
		case 0x0000
	}
}









